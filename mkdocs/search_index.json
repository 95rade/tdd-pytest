{
    "docs": [
        {
            "location": "/",
            "text": "Test driven development with pytest\n\u00b6\n\n\nTest Driven Development with Python\n book by  Harry Percival is a\nnice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple \nDjango\n based web app\nusing \nunittest\n and \nSelenium\n for testing. Very\ncommon setup.  Here we will develop the same app using \nFlask\n and\ntest it with \npytest\n + \npytest-splinter\n\nand \npytest-bdd\n extensions.\n\n\nThis guide is aimed at intermediate level developers with some experience in web\nprogramming. \u201cIntermediate\u201d means familiarity with things like \u201curl routing\u201d,\n\u201chttp requests\u201d, \u201chtml templating\u201d and the general MVC pattern.  There is little\nexplanation and comments about the code.  It is not a \u201ctranslation\u201d of Harry\u2019s\nbook.  Get and read the book or at least checkout the preface and some beginning\nchapters to get more context.\n\n\nConventions\n\u00b6\n\n\nThere are two types of code blocks:\n\n\ncommand line \u2013 what you need to type in a terminal (\n$\n indicates standard\n\nbash\n shell prompt)\n\n\n$ whoami\nivan\n$ python -V\nPython 3.5.0\n\n\n\n\npython code \u2013 what you need to type inside a text editor (the first line\nstarting with \n#\n indicates the path to file relative to project\u2019s root directory.\n\n\n# path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "About"
        },
        {
            "location": "/#test-driven-development-with-pytest",
            "text": "Test Driven Development with Python  book by  Harry Percival is a\nnice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple  Django  based web app\nusing  unittest  and  Selenium  for testing. Very\ncommon setup.  Here we will develop the same app using  Flask  and\ntest it with  pytest  +  pytest-splinter \nand  pytest-bdd  extensions.  This guide is aimed at intermediate level developers with some experience in web\nprogramming. \u201cIntermediate\u201d means familiarity with things like \u201curl routing\u201d,\n\u201chttp requests\u201d, \u201chtml templating\u201d and the general MVC pattern.  There is little\nexplanation and comments about the code.  It is not a \u201ctranslation\u201d of Harry\u2019s\nbook.  Get and read the book or at least checkout the preface and some beginning\nchapters to get more context.",
            "title": "Test driven development with pytest"
        },
        {
            "location": "/#conventions",
            "text": "There are two types of code blocks:  command line \u2013 what you need to type in a terminal ( $  indicates standard bash  shell prompt)  $ whoami\nivan\n$ python -V\nPython 3.5.0  python code \u2013 what you need to type inside a text editor (the first line\nstarting with  #  indicates the path to file relative to project\u2019s root directory.  # path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "Conventions"
        },
        {
            "location": "/tdd-basics/",
            "text": "TDD Basics\n\u00b6\n\n\nHere we will build a simple todo app following roughly the same steps as in the\nPart I of \nTDD with Python\n book.\n\n\nProject setup\n\u00b6\n\n\nFist of all we need to create the project\u2019s directory structure and install\nminimal requirments into a \nvirtualenv\n. Then we create a \u201cfailing\u201d test\nfollowed by a minimal Flask app, just to get the test to pass.\n\n\n$ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.0\n\n$ pip install Flask\n$ pip install pytest pytest-xdist pytest-splinter\n\n\n\n\nCreate the \napp\n and \ntests\n dirs:\n\n\n$ mkdir todoapp && mkdir tests\n$ touch tests/functional_tests.py\n\n\n\n\n# tests/functional_tests.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n\n\nRun the test and see it fail.\n\n\n$ python tests/functional_test.py\nTraceback (most recent call last):\n  File \"tests/functional_test.py\", line 8, in <module>\n      assert browser.is_text_present('hello world')\n      AssertionError\n\n\n\n\nNote that we haven\u2019t actually used \npytest\n yet. \nfunctional_test.py\n is just\na regular python script\n1\n. Now, create a basic flask app:\n\n\n# todoapp/__init__.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\nOpen another terminal, activate \nvenv\n, and run the app:\n\n\n$ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n\n\n\nRerun the test and see it pass.\n\n\nAt this point you should have the following files in your project dir:\n\n\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...\n\n\n\n\nStarting the actual app\n\u00b6\n\n\nWe can use \nfunctional_test.py\n to guide the development of the todo app.  This\ncan be as simple as using comments to write a walkthrough the app\u2019s features by\nan imaginary user. This is a variation on\n\u201c\nReadme driven development\n\u201d theme.\n\n\n# tests/functional_test.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\n\n# She notices the page title and header mention to-do lists\n\n# She is invited to enter a to-do item straight away\n\n# She types \"Buy peacock feathers\" into a text box (Edith's hobby\n# is tying fly-fishing lures)\n\n# When she hits enter, the page updates, and now the page lists\n# \"1: Buy peacock feathers\" as an item in a to-do list\n\n# There is still a text box inviting her to add another item. She\n# enters \"Use peacock feathers to make a fly\" (Edith is very methodical)\n\n# The page updates again, and now shows both items on her list\n\n# Edith wonders whether the site will remember her list. Then she sees\n# that the site has generated a unique URL for her -- there is some\n# explanatory text to that effect.\n\n# She visits that URL - her to-do list is still there.\n\n# Satisfied, she goes back to sleep\n\n\n\n\nUnittest\n is the standard Python module for creating and running tests.\n\nPytest\n is an alternative testing framework. It is arguably more \u201cpythonic\u201d\n(requires less boilerplate code) and easier to use. We can adapt\n\nfunctional_test.py\n to test the \u201ccheck homepage\u201d feature as follows:\n\n\n# tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef _r(route):\n    \"\"\" routing helper \"\"\"\n    if not route.startswith('/'):\n        route = '/' + route\n    return '%s%s' % (BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(_r('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...\n\n\n\n\nNote how the \nbrowser\n instance has been converted into a function decorated\nwith \nyield_fixture\n2\n. It does the job of both \nsetUp()\n and \ntearDown()\n methods\nof a \nunittest.TestCase\n. It is possible to organize tests into classes, but it\nis not required.\n\n\nBefore running \npytest\n, create a \nsetup.cfg\n to exclude \nvenv\n (and other dirs\nif needed) from being in the tests auto-discovery path.\n\n\n[pytest]\nnorecursedirs = .git venv\n\n\n\n\nNow run the test (note that \npytest\n\u2018s runner is \npy.test\n):\n\n\n$ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================\n\n\n\n\nUse \npy.test -ra\n if you want to see what is causing \npytest-warnings\n.\n\n\nBack to the app. \u201chello world\u201d is nice, but it has little to do with a todo app.\nThe test should look more like:\n\n\n# Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(_r('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n\n\n\n\n$ py.test\n<... skipped lines ...>\n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser = <splinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8>\n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(_r('/'))\n        # She notices the page title and header mention to-do lists\n>       assert 'To-Do' in browser.title\nE       assert 'To-Do' in ''\n<... skipped lines ...>\n\n\n\n\nNote the last line. It shows the actual value of \nbrowser.title\n during the\ntest run. Time to update the app:\n\n\n$ mkdir todoapp/templates\n$ touch todoapp/templates/home.html\n\n\n\n\n<!-- todoapp/templates/home.html -->\n<html>\n<head>\n  <title>To-Do</title>\n</head>\n\n<body>\n  <h1>My todos list</h1>\n</body>\n\n</html>\n\n\n\n\n# todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n\n\n\npy.test\n should now pass.\n\n\n\n\n\n\n\n\n\n\nNon-trivial apps will have many tests organized in multiple functions or\nclasses. That\u2019s when we need to use a \u201ctest runner\u201d \u2013 a command that discovers\nand runs all the tests, and then reports which have passed and which have\nfailed.\u00a0\n\u21a9\n\n\n\n\n\n\nPytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.\u00a0\n\u21a9",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#tdd-basics",
            "text": "Here we will build a simple todo app following roughly the same steps as in the\nPart I of  TDD with Python  book.",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#project-setup",
            "text": "Fist of all we need to create the project\u2019s directory structure and install\nminimal requirments into a  virtualenv . Then we create a \u201cfailing\u201d test\nfollowed by a minimal Flask app, just to get the test to pass.  $ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.0\n\n$ pip install Flask\n$ pip install pytest pytest-xdist pytest-splinter  Create the  app  and  tests  dirs:  $ mkdir todoapp && mkdir tests\n$ touch tests/functional_tests.py  # tests/functional_tests.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')  Run the test and see it fail.  $ python tests/functional_test.py\nTraceback (most recent call last):\n  File \"tests/functional_test.py\", line 8, in <module>\n      assert browser.is_text_present('hello world')\n      AssertionError  Note that we haven\u2019t actually used  pytest  yet.  functional_test.py  is just\na regular python script 1 . Now, create a basic flask app:  # todoapp/__init__.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ == \"__main__\":\n    app.run()  Open another terminal, activate  venv , and run the app:  $ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)  Rerun the test and see it pass.  At this point you should have the following files in your project dir:  \u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...",
            "title": "Project setup"
        },
        {
            "location": "/tdd-basics/#starting-the-actual-app",
            "text": "We can use  functional_test.py  to guide the development of the todo app.  This\ncan be as simple as using comments to write a walkthrough the app\u2019s features by\nan imaginary user. This is a variation on\n\u201c Readme driven development \u201d theme.  # tests/functional_test.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\n\n# She notices the page title and header mention to-do lists\n\n# She is invited to enter a to-do item straight away\n\n# She types \"Buy peacock feathers\" into a text box (Edith's hobby\n# is tying fly-fishing lures)\n\n# When she hits enter, the page updates, and now the page lists\n# \"1: Buy peacock feathers\" as an item in a to-do list\n\n# There is still a text box inviting her to add another item. She\n# enters \"Use peacock feathers to make a fly\" (Edith is very methodical)\n\n# The page updates again, and now shows both items on her list\n\n# Edith wonders whether the site will remember her list. Then she sees\n# that the site has generated a unique URL for her -- there is some\n# explanatory text to that effect.\n\n# She visits that URL - her to-do list is still there.\n\n# Satisfied, she goes back to sleep  Unittest  is the standard Python module for creating and running tests. Pytest  is an alternative testing framework. It is arguably more \u201cpythonic\u201d\n(requires less boilerplate code) and easier to use. We can adapt functional_test.py  to test the \u201ccheck homepage\u201d feature as follows:  # tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef _r(route):\n    \"\"\" routing helper \"\"\"\n    if not route.startswith('/'):\n        route = '/' + route\n    return '%s%s' % (BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(_r('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...  Note how the  browser  instance has been converted into a function decorated\nwith  yield_fixture 2 . It does the job of both  setUp()  and  tearDown()  methods\nof a  unittest.TestCase . It is possible to organize tests into classes, but it\nis not required.  Before running  pytest , create a  setup.cfg  to exclude  venv  (and other dirs\nif needed) from being in the tests auto-discovery path.  [pytest]\nnorecursedirs = .git venv  Now run the test (note that  pytest \u2018s runner is  py.test ):  $ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================  Use  py.test -ra  if you want to see what is causing  pytest-warnings .  Back to the app. \u201chello world\u201d is nice, but it has little to do with a todo app.\nThe test should look more like:  # Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(_r('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title  $ py.test\n<... skipped lines ...>\n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser = <splinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8>\n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(_r('/'))\n        # She notices the page title and header mention to-do lists\n>       assert 'To-Do' in browser.title\nE       assert 'To-Do' in ''\n<... skipped lines ...>  Note the last line. It shows the actual value of  browser.title  during the\ntest run. Time to update the app:  $ mkdir todoapp/templates\n$ touch todoapp/templates/home.html  <!-- todoapp/templates/home.html -->\n<html>\n<head>\n  <title>To-Do</title>\n</head>\n\n<body>\n  <h1>My todos list</h1>\n</body>\n\n</html>  # todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run(debug=True)  py.test  should now pass.      Non-trivial apps will have many tests organized in multiple functions or\nclasses. That\u2019s when we need to use a \u201ctest runner\u201d \u2013 a command that discovers\nand runs all the tests, and then reports which have passed and which have\nfailed.\u00a0 \u21a9    Pytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.\u00a0 \u21a9",
            "title": "Starting the actual app"
        },
        {
            "location": "/tdd-advanced/",
            "text": "Testing with pytest-bdd\n\u00b6\n\n\nBeyond unit testing\n\u00b6",
            "title": "TDD Advanced"
        },
        {
            "location": "/tdd-advanced/#testing-with-pytest-bdd",
            "text": "",
            "title": "Testing with pytest-bdd"
        },
        {
            "location": "/tdd-advanced/#beyond-unit-testing",
            "text": "",
            "title": "Beyond unit testing"
        }
    ]
}