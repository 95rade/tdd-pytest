{
    "docs": [
        {
            "location": "/",
            "text": "Test driven development with pytest\n\u00b6\n\n\nTest Driven Development with Python\n book by  Harry Percival is\na nice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple \nDjango\n based web app\nusing \nunittest\n and \nSelenium\n for testing. Very\ncommon setup.  Here we will develop the same app using \nFlask\n and\ntest it with \npytest\n + \npytest-splinter\n and\n\npytest-bdd\n extensions.\n\n\nThis guide is aimed at developers with some experience in Python and web\nprogramming. This means some familiarity with things like \u201curl routing\u201d, \u201chttp\nrequests\u201d, \u201chtml templating\u201d and the general MVC pattern. Basic knowledge about\nhow to use the command line interface (we\u2019ll use \nbash\n) is also assumed.\n\n\nThis is a very basic how-to-get-started-with-testing guide. Hopefully enough to\novercome the initial learning barrier. I\u2019m not a \u201ctesting expert\u201d, and I don\u2019t\nwant to get into why anybody should be doing TDD or get into the depths of\nwhat\u2019s a \u201cunit\u201d, \u201cfunctional\u201d, \u201cacceptance\u201d or \u201cintegration\u201d test. You can read\nmore about testing in Harry\u2019s book, \nwikipedia\n and other\nauthoritative sources like \nthis one\n or \nthat one\n.\n\nhttp://gojko.net/\n is another useful resource.\n\n\nBoth this guide and the source of the app are on \nGitHub\n.\n\n\nConventions\n\u00b6\n\n\nThere are two types of code blocks:\n\n\ncommand line \u2013 what you need to type in a terminal (\n$\n indicates standard\n\nbash\n shell prompt),\n\n\n$ whoami\nivan\n$ python -V\nPython 3.5.0\n\n\n\n\nand Python code \u2013 what you need to type inside a text editor (the first line\nstarting with \n#\n indicates the path to file relative to project\u2019s root\ndirectory.\n\n\n# path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "About"
        },
        {
            "location": "/#test-driven-development-with-pytest",
            "text": "Test Driven Development with Python  book by  Harry Percival is\na nice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple  Django  based web app\nusing  unittest  and  Selenium  for testing. Very\ncommon setup.  Here we will develop the same app using  Flask  and\ntest it with  pytest  +  pytest-splinter  and pytest-bdd  extensions.  This guide is aimed at developers with some experience in Python and web\nprogramming. This means some familiarity with things like \u201curl routing\u201d, \u201chttp\nrequests\u201d, \u201chtml templating\u201d and the general MVC pattern. Basic knowledge about\nhow to use the command line interface (we\u2019ll use  bash ) is also assumed.  This is a very basic how-to-get-started-with-testing guide. Hopefully enough to\novercome the initial learning barrier. I\u2019m not a \u201ctesting expert\u201d, and I don\u2019t\nwant to get into why anybody should be doing TDD or get into the depths of\nwhat\u2019s a \u201cunit\u201d, \u201cfunctional\u201d, \u201cacceptance\u201d or \u201cintegration\u201d test. You can read\nmore about testing in Harry\u2019s book,  wikipedia  and other\nauthoritative sources like  this one  or  that one . http://gojko.net/  is another useful resource.  Both this guide and the source of the app are on  GitHub .",
            "title": "Test driven development with pytest"
        },
        {
            "location": "/#conventions",
            "text": "There are two types of code blocks:  command line \u2013 what you need to type in a terminal ( $  indicates standard bash  shell prompt),  $ whoami\nivan\n$ python -V\nPython 3.5.0  and Python code \u2013 what you need to type inside a text editor (the first line\nstarting with  #  indicates the path to file relative to project\u2019s root\ndirectory.  # path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "Conventions"
        },
        {
            "location": "/tdd-basics/",
            "text": "TDD Basics\n\u00b6\n\n\nHere we will build a simple todo app following roughly the same steps as in the\nPart I of \nTDD with Python\n book.\n\n\nProject setup\n\u00b6\n\n\nFist of all we need to create the project\u2019s directory structure and install\nminimal requirements into a \u201cvirtualenv\u201d. Then we write the first test which\nshould obviously \u201cfail\u201d since there is no actual application code written at\nthis point. And then we write a minimal Flask app, to get the test to pass.\n\n\n$ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.\n\n$ pip install Flask\n$ pip install pytest pytest-splinter\n\n\n\n\nCreate the \napp\n and \ntests\n dirs:\n\n\n$ mkdir todoapp tests\n\n\n\n\nManual testing of a web application usually involves the following steps:\n\n\n\n\nopen a web browser\n\n\nnavigate to some url\n\n\ncheck some page rendering detail\n\n\nclose the browser\n\n\n\n\nHere is how to do this with \nsplinter\n:\n\n\n# tests/functional_test.py\n\nfrom splinter import Browser\n\nbrowser = Browser()\nurl = 'http://localhost'\nbrowser.visit(url)\nassert browser.is_text_present('hello world')\nbrowser.quit()\n\n\n\n\nRun the test:\n\n\n$ python tests/functional_test.py\nTraceback (most recent call last):\n  File \"tests/functional_test.py\", line 8, in <module>\n      assert browser.is_text_present('hello world')\n      AssertionError\n\n\n\n\nAssertionError\n indicates test failure. Note that we haven\u2019t actually used\n\npytest\n yet. The file containing our first test is just a regular python\nscript.\n\n\n\n\nNote\n\n\nNon-trivial apps will have many tests organized in multiple functions or\nclasses. That\u2019s when we need to use a \u201ctest runner\u201d \u2013 a command that discovers\nand runs all the tests, and then reports which ones have passed or failed.\n\n\n\n\nNow, let\u2019s create a basic flask app:\n\n\n# todoapp/__init__.py\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ == '__main__':\n    app.run()\n\n\n\n\nOpen another terminal, activate \nvenv\n, and run the app:\n\n\n$ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n\n\n\nRerun the test and see it\u2026 fail. By default flask apps are running on port\n5000. Fix the \nurl\n in \nfunctional_test.py\n to take that into account, rerun\nthe test, and now it should pass.\n\n\nAt this point you should have the following files in your project\u2019s directory:\n\n\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...\n\n\n\n\nStarting the actual app\n\u00b6\n\n\nWe can use \nfunctional_test.py\n to guide the development of our todo app. This\ncan be as simple as using comments to write a walk-through the app\u2019s features by\nan imaginary user. This is a variation on the\n\u201c\nReadme driven development\n\u201d theme.\n\n\n# tests/functional_test.py\n\nfrom splinter import Browser\n\nbrowser = Browser()\nurl = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\nbrowser.visit(url)\n\n# She notices the page title and header mention to-do lists\nassert 'Todo' in browser.title\nheader = browser.find_by_tag('h1').first\nassert 'Todo list' in header.text\n\n# She is invited to enter a to-do item straight away\n\n# She types \"Buy peacock feathers\" into a text box\n\n# When she hits enter, the page updates, and now the page lists\n# \"1: Buy peacock feathers\" as an item in a to-do list\n\n# ...\nbrowser.quit()\n\n\n\n\nWe don\u2019t need to figure out how to test all the features at once.\nThinking about 2 or 3 \u201cnext\u201d features provides enough context to start\nimplementing the app. But before doing that, we need to discuss about the\ndifference between \u201cfunctional\u201d and \u201cunit\u201d tests.\n\n\nFunctional vs unit tests\n\u00b6\n\n\nConsidering an application from a user\u2019s perspective helps to stay focused on\nbuilding what\u2019s actually needed. Writing tests from the same perspective allows\nverification that those needed parts of the app behave or function as intended.\nHence they are called \nfunctional\n tests. Note that there is no reference to\n\nflask\n anywhere in \nfuncational_test.py\n. The user is not expected to know\nanything about the app\u2019s implementation details. He or she is only interested in\nfunctionality. The developer, on the other hand, must make all the technical\nimplementation decisions, which framework to use, how to organize the code\u2026\nActual application code also need to be tested, and done so from the\ndevelopper\u2019s perspective. Such tests are called \nunit\n tests. \u201cUnit\u201d refers to\na \u201cunit of software code\u201d. Usually it means a function (\ndef foo():...\n) or a on\nobject\u2019s method, but there isn\u2019t really a more precise or agreed upon definition\nof \u201cunit of code\u201d.\n\n\nUnittest vs pytest\n\u00b6\n\n\nUnittest\n is the standard Python module for creating and running tests. The\nname is confusing because this module is used to write both \u201cunit\u201d and\n\u201cfunctional\u201d tests. \nPytest\n is an alternative testing package. It can also be\nused to write both \u201cunit\u201d and \u201cfunctional\u201d tests. The syntax for writing tests\nusing \npytest\n requires less boilerplate code compared to \nunittest\n, and it\nfeels more in line with \u201cSimple is better than complex\u201d (see\n\npep20\n). \nPytest\n also performs test\ndiscovery, execution, and reporting. In that sense, it is an alternative to\n\nunittest\n + \nnose\n combination.\n\n\nEnough \u201ctheory\u201d, back to the app. We need to change our \u201chello world\u201d app into\na \u201ctodo\u201d app. According to our first couple of functional requirments, the app\nshould return an html page with a title and a header containing \u201cTodo\u201d text.\nIt is very simple to do this in \nflask\n, but let\u2019s write a unit test for it\nfirst. Test-driven means test code first, actual code later.\n\n\n# tests/unit_test.py\n\nfrom todoapp import app\n\ndef test_home_page_header():\n    client = app.test_client()\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<title>Todo</title>' in html\n    assert '<h1>Todo list</h1>' in html\n\n\n\n\nThis looks quite similar to our function test except that we are using \nflask\n\u2018s\nbuilt-in test \nclient\n and checking explicitly for a valid HTTP response code.\nAlso, the test is written as a function. This is how tests (both unit and\nfunctional) are usually created when using \npytest\n.  \nPytest\n comes with a\n\npy.test\n command which discovers and runs the tests. Without arguments, it\nlooks recursively for \ntests/\n directories and \n*_test.py\n files , and executes\nany function or method with a \ntest\n inside it\u2019s name. For now we want to run\nonly the unit tests.\n\n\n\n\nNote on \nclient\n\n\n\u201cClient\u201d is a generic way to refer to code or application running on the\n user\u2019s side (like web browsers) in the client-server software design model.\n\n\n\n\n$ py.test tests/unit_test.py\n============================= test session starts ==============================\n... skip lines ...\n_____________________ ERROR collecting tests/unit_test.py ______________________\ntests/unit_test.py:2: in <module>\n    from todoapp import app\nE   ImportError: No module named 'todoapp'\n================== 1 pytest-warnings, 1 error in 0.01 seconds ==================\n\n\n\n\nThe app\u2019s module is not in the Python\u2019s path. The simplest way to fix this is\nto set the \nPYTHONPATH\n shell variable to the current dir:\n\n\n$ export PYTHONPATH='.'\n$ py.test tests/unit_test.py\n=================================== FAILURES ===================================\n____________________________ test_home_page_header _____________________________\n\n    def test_home_page_header():\n        client = app.test_client()\n        rsp = client.get('/')\n        assert rsp.status == '200 OK'\n>       assert '<title>Todo</title>' in html\nE       assert '<title>Todo</title>' in 'hello world'\n\ntests/unit_test.py:8: AssertionError\n================= 1 failed, 1 pytest-warnings in 0.02 seconds ==================\n\n\n\n\nSo, the app responds to a GET request, but of course it is not returning any\nhtml. Note that we don\u2019t need to have the app running while executing unit\ntests. Let\u2019s fix the app:\n\n\n# todoapp/__init__.py\n\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\nAnd create a page template.\n\n\n$ mkdir todoapp/templates\n\n\n\n\n<!-- todoapp/templates/home.html -->\n\n<html>\n<head>\n  <title>Todo</title>\n</head>\n<body>\n  <h1>Todo list</h1>\n</body>\n</html>\n\n\n\n\nRerun the test with a verbose flag on.\n\n\n$ py.test -v tests/unit_test.py\n============================= test session starts ==============================\n... skip lines ...\ncollected 1 items\n\ntests/unit_test.py::test_home_page_header PASSED\n\n================= 1 passed, 1 pytest-warnings in 0.03 seconds ==================\n\n\n\n\nUse \npy.test -ra\n if you want to see what is causing \npytest-warnings\n.  If you\nstart the app and run \n$ python tests/function_test.py\n it should also pass\nwithout failing. It\u2019s time to add more functional tests and make it\n\u201cpytest-complient\u201d.\n\n\n# tests/function_test.py\n\nfrom splinter import Browser\n\nURL = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\ndef test_checkout_app():\n    browser = Browser()\n    # She goes to check out its homepage\n    browser.visit(URL)\n\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n    header = browser.find_by_tag('h1').first\n    assert 'todos' in header.text\n\n    # She is invited to enter a to-do item straight away\n    inputbox = browser.find_by_id('new_todo_item').first\n    assert inputbox['placeholder'] == 'Enter a to-do item'\n\n    # ...\n\n\n\n\nThe html template needs a \n<form>\n and \n<input>\n elements. But unit test needs\nto be updated first.\n\n\n# tests/unit_test.py\n\nfrom todoapp import app\n\ndef test_home_page_header():\n    client = app.test_client()\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<title>Todo</title>' in html\n    assert '<h1>Todo list</h1>' in html\n    assert '<form>' in html\n    assert '<input id=' in html\n\n\n\n\nRun the test and see it fail. Then update the template file.\n\n\n<!-- todoapp/templates/home.html -->\n\n<html>\n<head>\n  <title>Todo</title>\n</head>\n<body>\n  <h1>Todo list</h1>\n  <form>\n    <input id=\"new_todo_item\" name=\"todo_text\"/>\n  </form>\n</body>\n</html>\n\n\n\n\n\n\nBig reorg: half-backed bits and pieces below\n\n\nTesting user interactions\n\u00b6\n\n\nAt this point we need to decide what to do when the user hits \u201cEnter\u201d preferably\nwithout resorting to \ncss tricks\n and javascript. Turns out\nthat an html form containing a single \n<input>\n is \nimplicitly\nsubmitted\n on\n\u201cEnter\u201d. All we need to do is to specify that submit method is \u201cPOST\u201d and to\nadd a list or table to the template which will display submitted todo items. But\nwrite the tests first!\n\n\n# tests/unit_test.py\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<form' in html\n    assert '<input' in html\n    assert '<table' in html\n\ndef test_home_page_accepts_post_request(client):\n    rsp = client.post('/', data={\"todo_text\": \"do something useful\"})\n    assert rsp.status == '200 OK'\n    assert 'do something useful' in rsp.get_data(as_text=True)\n\n\n\n\nNow update the template.\n\n\n<!-- todoapp/templates/home.html -->\n<body>\n  <h1>My todos list</h1>\n  <form method=\"POST\">\n    <input id=\"new_todo_item\" name=\"todo_text\"/>\n  </form>\n\n  <table id=\"todo_list_table\"></table>\n</body>\n\n\n\n\nRun unit tests.\n\n\n$ py.test tests/unit_test.py\n================================ test session starts =================================\n\n    def test_home_page_accepts_post_request(client):\n        rsp = client.post('/')\n>       assert rsp.status == '200 OK'\nE       assert '405 METHOD NOT ALLOWED' == '200 OK'\nE         - 405 METHOD NOT ALLOWED\nE         + 200 OK\n\ntests/unit_test.py:21: AssertionError\n=============== 1 failed, 1 passed, 1 pytest-warnings in 0.03 seconds ================\n\n\n\n\n\nFlask routes accept only \u201cGET\u201d requests by default, but this is easily changed\nusing \nmethods\n keyword. We will also need to import flask\u2019s \nrequest\n object.\n\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'POST':\n        new_item = request.form.get('todo_text')\n        return 'got new item: %s' % new_item\n    return render_template('home.html')\n\n\n\n\n\n\nOne \u201csmall\u201d problem with the above approach is that \nbrowser\n is a global object\nwhose state could be modifed by different test functions. Global variables are\nparticularly bad in the testing context where we must be sure that the same test\nfunctions are always executed under identical conditions. To ensure this, each\ntest function should create and destroy it\u2019s context. To avoid code repetition,\nwe can use pytest\u2019s \nfixtures\n:\n\n\n\n\nNote\n\n\nYield fixtures allow very simple setup/teardown syntax.\n\n\n\n\n# tests/functional_tests.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nurl = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_check_homepage(browser):\n    browser.visit(url)\n    assert browser.is_text_present('???')\n\n# She notices the page title and header mention to-do lists\ndef test_todo_in_page_title(browser):\n    browser.visit(url)\n    assert 'Todo' in browser.title\n\n\n\n\nWe can run these two tests using \n$ py.test tests/functional_tests.py\n.  Of\ncourse both assertions will fail. We also notice that opening and closing a\nbrowser takes a couple of seconds.\n\n\n\n\nOn the other hand, unit tests (the concept and not the\n\nunittest\n module) are supposed to test an application from the developer\u2019s\npoint of view. Unit tests should cover very specific and usually very small\nparts of code. Therefore, there should be many more unit tests than functional\ntests.  Because of that unit tests must be fast. Opening and closing browsers is\nnot very useful in this context. As described in the TDDPy book, the development\nprocess goes as follows:\n\n\n\n\nStart by writing a functional test, describing the new functionality from\n    the user\u2019s point of view.\n\n\nOnce we have a functional test that fails, we start to think about how to\n    write code that can get it to pass (or at least to get past its current\n    failure). We now use one or more unit tests to define how we want our code to\n    behave \u2013 the idea is that each line of production code we write should be\n    tested by (at least) one of our unit tests.\n\n\nOnce we have a failing unit test, we write the smallest amount of\n    application code we can, just enough to get the unit test to pass. We may\n    iterate between steps 2 and 3 a few times, until we think the functional test\n    will get a little further.\n\n\nNow we can rerun our functional tests and see if they pass, or get a little\n    further. That may prompt us to write some new unit tests, and some new code,\n    and so on.\n\n\n\n\nLet\u2019s create a unit test for the todo app using flask\u2019s test client[^3] which\ndoes the same thing as the \ntest_can_check_homepage()\n inside\n\nfunctional_test.py\n:\n\n\n# tests/unit_test.py\n\nimport pytest\nfrom todoapp import app\n\n@pytest.fixture(scope='session')\ndef client():\n    app.config['TESTING'] = True\n    return app.test_client()\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    assert '<title>To-Do</title>' in rsp.get_data(as_text=True)\n\n\n\n\nand run it\n\n\n$ py.test tests/unit_test.py\n========================================== ERRORS ==========================================\n___________________________ ERROR collecting tests/unit_test.py ____________________________\ntests/unit_test.py:2: in <module>\n    import todoapp\nE   ImportError: No module named 'todoapp'\n\n\n\n\nThe app\u2019s module is not in the Python\u2019s path, so \npytest\n can\u2019t import it. The\nsimplest way to fix this is to set the \nPYTHONPATH\n shell variable to the\ncurrent dir:\n\n\n$ export PYTHONPATH='.'\n\n$ py.test -v tests/unit_test.py\n=================================== test session starts ====================================\n\ntests/unit_test.py::test_home_page_returns_correct_html PASSED\n\n======================= 1 passed, 1 pytest-warnings in 0.02 seconds\n\n\n\n\n0.02 seconds is much better compared to 2.5 seconds needed to start a browser.\n\n\nSince we know that the \nhome\n view should return \nhome.html\n template,\nwe can check the returned html as follows:\n\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    tpl = app.jinja_env.get_template('home.html')\n    assert tpl.render() == rsp.get_data(as_text=True)\n\n\n\n\nAt this point your project dir should look like (excluding \n*.pyc\n and\n\n__pycache__\n dir):\n\n\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 functional_test.py\n\u2502 \u00a0 \u2514\u2500\u2500 unit_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 templates\n\u2502    \u00a0\u00a0 \u2514\u2500\u2500 home.html\n\u2514\u2500\u2500 venv\n  \u00a0 \u2514\u2500\u2500 bin\n...\n\n\n\n\nUnittest\n is the standard Python module for creating and running tests.\n\nPytest\n is an alternative testing framework. It requires less boilerplate code\nand is somewhat easier to use. We can adapt \nfunctional_test.py\n to test the\n\u201ccheck homepage\u201d feature as follows:\n\n\n# tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef url(route):\n    return '{}/{}'.format(BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(url('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...\n\n\n\n\nNote how the \nbrowser\n instance has been converted into a function decorated\nwith \nyield_fixture\n1\n. It does the job of both \nsetUp()\n and \ntearDown()\n\nmethods of a \nunittest.TestCase\n. It is possible to organize tests into classes,\nbut it is not required.\n\n\nBefore running \npytest\n, create a \nsetup.cfg\n file to exclude \nvenv\n (and other\ndirs if needed) from being in the tests auto-discovery path.\n\n\n[pytest]\nnorecursedirs = .git venv\n\n\n\n\nNow run the test (note that \npytest\n\u2018s runner is \npy.test\n):\n\n\n$ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================\n\n\n\n\nUse \npy.test -ra\n if you want to see what is causing \npytest-warnings\n.\n\n\nBack to the app. \u201chello world\u201d is nice, but it has little to do with a todo app.\nThe test should look more like:\n\n\n# Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n\n\n\n\n$ py.test\n<... skipped lines ...>\n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser = <splinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8>\n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(url('/'))\n        # She notices the page title and header mention to-do lists\n>       assert 'To-Do' in browser.title\nE       assert 'To-Do' in ''\n<... skipped lines ...>\n\n\n\n\nNote the last line. It shows the actual value of \nbrowser.title\n during the\ntest run. Time to update the app:\n\n\n$ mkdir todoapp/templates\n$ touch todoapp/templates/home.html\n\n\n\n\n<!-- todoapp/templates/home.html -->\n<html>\n<head>\n  <title>To-Do</title>\n</head>\n\n<body>\n  <h1>My todos list</h1>\n</body>\n\n</html>\n\n\n\n\n# todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n\n\n\npy.test\n should now pass.\n\n\n\n\nIf you want a more explicit error message, change the assertion line like this:\n\n\n\n    assert any(row.text == '1: Buy peacock feathers' for row in rows), \\\n           'New to-do item did not appear in the table'\n\n\n\n\n\n\n\n\n\n\n\n\n\nPytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.\u00a0\n\u21a9",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#tdd-basics",
            "text": "Here we will build a simple todo app following roughly the same steps as in the\nPart I of  TDD with Python  book.",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#project-setup",
            "text": "Fist of all we need to create the project\u2019s directory structure and install\nminimal requirements into a \u201cvirtualenv\u201d. Then we write the first test which\nshould obviously \u201cfail\u201d since there is no actual application code written at\nthis point. And then we write a minimal Flask app, to get the test to pass.  $ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.\n\n$ pip install Flask\n$ pip install pytest pytest-splinter  Create the  app  and  tests  dirs:  $ mkdir todoapp tests  Manual testing of a web application usually involves the following steps:   open a web browser  navigate to some url  check some page rendering detail  close the browser   Here is how to do this with  splinter :  # tests/functional_test.py\n\nfrom splinter import Browser\n\nbrowser = Browser()\nurl = 'http://localhost'\nbrowser.visit(url)\nassert browser.is_text_present('hello world')\nbrowser.quit()  Run the test:  $ python tests/functional_test.py\nTraceback (most recent call last):\n  File \"tests/functional_test.py\", line 8, in <module>\n      assert browser.is_text_present('hello world')\n      AssertionError  AssertionError  indicates test failure. Note that we haven\u2019t actually used pytest  yet. The file containing our first test is just a regular python\nscript.   Note  Non-trivial apps will have many tests organized in multiple functions or\nclasses. That\u2019s when we need to use a \u201ctest runner\u201d \u2013 a command that discovers\nand runs all the tests, and then reports which ones have passed or failed.   Now, let\u2019s create a basic flask app:  # todoapp/__init__.py\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ == '__main__':\n    app.run()  Open another terminal, activate  venv , and run the app:  $ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)  Rerun the test and see it\u2026 fail. By default flask apps are running on port\n5000. Fix the  url  in  functional_test.py  to take that into account, rerun\nthe test, and now it should pass.  At this point you should have the following files in your project\u2019s directory:  \u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...",
            "title": "Project setup"
        },
        {
            "location": "/tdd-basics/#starting-the-actual-app",
            "text": "We can use  functional_test.py  to guide the development of our todo app. This\ncan be as simple as using comments to write a walk-through the app\u2019s features by\nan imaginary user. This is a variation on the\n\u201c Readme driven development \u201d theme.  # tests/functional_test.py\n\nfrom splinter import Browser\n\nbrowser = Browser()\nurl = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\nbrowser.visit(url)\n\n# She notices the page title and header mention to-do lists\nassert 'Todo' in browser.title\nheader = browser.find_by_tag('h1').first\nassert 'Todo list' in header.text\n\n# She is invited to enter a to-do item straight away\n\n# She types \"Buy peacock feathers\" into a text box\n\n# When she hits enter, the page updates, and now the page lists\n# \"1: Buy peacock feathers\" as an item in a to-do list\n\n# ...\nbrowser.quit()  We don\u2019t need to figure out how to test all the features at once.\nThinking about 2 or 3 \u201cnext\u201d features provides enough context to start\nimplementing the app. But before doing that, we need to discuss about the\ndifference between \u201cfunctional\u201d and \u201cunit\u201d tests.",
            "title": "Starting the actual app"
        },
        {
            "location": "/tdd-basics/#functional-vs-unit-tests",
            "text": "Considering an application from a user\u2019s perspective helps to stay focused on\nbuilding what\u2019s actually needed. Writing tests from the same perspective allows\nverification that those needed parts of the app behave or function as intended.\nHence they are called  functional  tests. Note that there is no reference to flask  anywhere in  funcational_test.py . The user is not expected to know\nanything about the app\u2019s implementation details. He or she is only interested in\nfunctionality. The developer, on the other hand, must make all the technical\nimplementation decisions, which framework to use, how to organize the code\u2026\nActual application code also need to be tested, and done so from the\ndevelopper\u2019s perspective. Such tests are called  unit  tests. \u201cUnit\u201d refers to\na \u201cunit of software code\u201d. Usually it means a function ( def foo():... ) or a on\nobject\u2019s method, but there isn\u2019t really a more precise or agreed upon definition\nof \u201cunit of code\u201d.",
            "title": "Functional vs unit tests"
        },
        {
            "location": "/tdd-basics/#unittest-vs-pytest",
            "text": "Unittest  is the standard Python module for creating and running tests. The\nname is confusing because this module is used to write both \u201cunit\u201d and\n\u201cfunctional\u201d tests.  Pytest  is an alternative testing package. It can also be\nused to write both \u201cunit\u201d and \u201cfunctional\u201d tests. The syntax for writing tests\nusing  pytest  requires less boilerplate code compared to  unittest , and it\nfeels more in line with \u201cSimple is better than complex\u201d (see pep20 ).  Pytest  also performs test\ndiscovery, execution, and reporting. In that sense, it is an alternative to unittest  +  nose  combination.  Enough \u201ctheory\u201d, back to the app. We need to change our \u201chello world\u201d app into\na \u201ctodo\u201d app. According to our first couple of functional requirments, the app\nshould return an html page with a title and a header containing \u201cTodo\u201d text.\nIt is very simple to do this in  flask , but let\u2019s write a unit test for it\nfirst. Test-driven means test code first, actual code later.  # tests/unit_test.py\n\nfrom todoapp import app\n\ndef test_home_page_header():\n    client = app.test_client()\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<title>Todo</title>' in html\n    assert '<h1>Todo list</h1>' in html  This looks quite similar to our function test except that we are using  flask \u2018s\nbuilt-in test  client  and checking explicitly for a valid HTTP response code.\nAlso, the test is written as a function. This is how tests (both unit and\nfunctional) are usually created when using  pytest .   Pytest  comes with a py.test  command which discovers and runs the tests. Without arguments, it\nlooks recursively for  tests/  directories and  *_test.py  files , and executes\nany function or method with a  test  inside it\u2019s name. For now we want to run\nonly the unit tests.   Note on  client  \u201cClient\u201d is a generic way to refer to code or application running on the\n user\u2019s side (like web browsers) in the client-server software design model.   $ py.test tests/unit_test.py\n============================= test session starts ==============================\n... skip lines ...\n_____________________ ERROR collecting tests/unit_test.py ______________________\ntests/unit_test.py:2: in <module>\n    from todoapp import app\nE   ImportError: No module named 'todoapp'\n================== 1 pytest-warnings, 1 error in 0.01 seconds ==================  The app\u2019s module is not in the Python\u2019s path. The simplest way to fix this is\nto set the  PYTHONPATH  shell variable to the current dir:  $ export PYTHONPATH='.'\n$ py.test tests/unit_test.py\n=================================== FAILURES ===================================\n____________________________ test_home_page_header _____________________________\n\n    def test_home_page_header():\n        client = app.test_client()\n        rsp = client.get('/')\n        assert rsp.status == '200 OK'\n>       assert '<title>Todo</title>' in html\nE       assert '<title>Todo</title>' in 'hello world'\n\ntests/unit_test.py:8: AssertionError\n================= 1 failed, 1 pytest-warnings in 0.02 seconds ==================  So, the app responds to a GET request, but of course it is not returning any\nhtml. Note that we don\u2019t need to have the app running while executing unit\ntests. Let\u2019s fix the app:  # todoapp/__init__.py\n\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run()  And create a page template.  $ mkdir todoapp/templates  <!-- todoapp/templates/home.html -->\n\n<html>\n<head>\n  <title>Todo</title>\n</head>\n<body>\n  <h1>Todo list</h1>\n</body>\n</html>  Rerun the test with a verbose flag on.  $ py.test -v tests/unit_test.py\n============================= test session starts ==============================\n... skip lines ...\ncollected 1 items\n\ntests/unit_test.py::test_home_page_header PASSED\n\n================= 1 passed, 1 pytest-warnings in 0.03 seconds ==================  Use  py.test -ra  if you want to see what is causing  pytest-warnings .  If you\nstart the app and run  $ python tests/function_test.py  it should also pass\nwithout failing. It\u2019s time to add more functional tests and make it\n\u201cpytest-complient\u201d.  # tests/function_test.py\n\nfrom splinter import Browser\n\nURL = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\ndef test_checkout_app():\n    browser = Browser()\n    # She goes to check out its homepage\n    browser.visit(URL)\n\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n    header = browser.find_by_tag('h1').first\n    assert 'todos' in header.text\n\n    # She is invited to enter a to-do item straight away\n    inputbox = browser.find_by_id('new_todo_item').first\n    assert inputbox['placeholder'] == 'Enter a to-do item'\n\n    # ...  The html template needs a  <form>  and  <input>  elements. But unit test needs\nto be updated first.  # tests/unit_test.py\n\nfrom todoapp import app\n\ndef test_home_page_header():\n    client = app.test_client()\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<title>Todo</title>' in html\n    assert '<h1>Todo list</h1>' in html\n    assert '<form>' in html\n    assert '<input id=' in html  Run the test and see it fail. Then update the template file.  <!-- todoapp/templates/home.html -->\n\n<html>\n<head>\n  <title>Todo</title>\n</head>\n<body>\n  <h1>Todo list</h1>\n  <form>\n    <input id=\"new_todo_item\" name=\"todo_text\"/>\n  </form>\n</body>\n</html>   Big reorg: half-backed bits and pieces below",
            "title": "Unittest vs pytest"
        },
        {
            "location": "/tdd-basics/#testing-user-interactions",
            "text": "At this point we need to decide what to do when the user hits \u201cEnter\u201d preferably\nwithout resorting to  css tricks  and javascript. Turns out\nthat an html form containing a single  <input>  is  implicitly\nsubmitted  on\n\u201cEnter\u201d. All we need to do is to specify that submit method is \u201cPOST\u201d and to\nadd a list or table to the template which will display submitted todo items. But\nwrite the tests first!  # tests/unit_test.py\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '<form' in html\n    assert '<input' in html\n    assert '<table' in html\n\ndef test_home_page_accepts_post_request(client):\n    rsp = client.post('/', data={\"todo_text\": \"do something useful\"})\n    assert rsp.status == '200 OK'\n    assert 'do something useful' in rsp.get_data(as_text=True)  Now update the template.  <!-- todoapp/templates/home.html -->\n<body>\n  <h1>My todos list</h1>\n  <form method=\"POST\">\n    <input id=\"new_todo_item\" name=\"todo_text\"/>\n  </form>\n\n  <table id=\"todo_list_table\"></table>\n</body>  Run unit tests.  $ py.test tests/unit_test.py\n================================ test session starts =================================\n\n    def test_home_page_accepts_post_request(client):\n        rsp = client.post('/')\n>       assert rsp.status == '200 OK'\nE       assert '405 METHOD NOT ALLOWED' == '200 OK'\nE         - 405 METHOD NOT ALLOWED\nE         + 200 OK\n\ntests/unit_test.py:21: AssertionError\n=============== 1 failed, 1 passed, 1 pytest-warnings in 0.03 seconds ================  Flask routes accept only \u201cGET\u201d requests by default, but this is easily changed\nusing  methods  keyword. We will also need to import flask\u2019s  request  object.  from flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'POST':\n        new_item = request.form.get('todo_text')\n        return 'got new item: %s' % new_item\n    return render_template('home.html')   One \u201csmall\u201d problem with the above approach is that  browser  is a global object\nwhose state could be modifed by different test functions. Global variables are\nparticularly bad in the testing context where we must be sure that the same test\nfunctions are always executed under identical conditions. To ensure this, each\ntest function should create and destroy it\u2019s context. To avoid code repetition,\nwe can use pytest\u2019s  fixtures :   Note  Yield fixtures allow very simple setup/teardown syntax.   # tests/functional_tests.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nurl = 'http://localhost:5000'\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_check_homepage(browser):\n    browser.visit(url)\n    assert browser.is_text_present('???')\n\n# She notices the page title and header mention to-do lists\ndef test_todo_in_page_title(browser):\n    browser.visit(url)\n    assert 'Todo' in browser.title  We can run these two tests using  $ py.test tests/functional_tests.py .  Of\ncourse both assertions will fail. We also notice that opening and closing a\nbrowser takes a couple of seconds.   On the other hand, unit tests (the concept and not the unittest  module) are supposed to test an application from the developer\u2019s\npoint of view. Unit tests should cover very specific and usually very small\nparts of code. Therefore, there should be many more unit tests than functional\ntests.  Because of that unit tests must be fast. Opening and closing browsers is\nnot very useful in this context. As described in the TDDPy book, the development\nprocess goes as follows:   Start by writing a functional test, describing the new functionality from\n    the user\u2019s point of view.  Once we have a functional test that fails, we start to think about how to\n    write code that can get it to pass (or at least to get past its current\n    failure). We now use one or more unit tests to define how we want our code to\n    behave \u2013 the idea is that each line of production code we write should be\n    tested by (at least) one of our unit tests.  Once we have a failing unit test, we write the smallest amount of\n    application code we can, just enough to get the unit test to pass. We may\n    iterate between steps 2 and 3 a few times, until we think the functional test\n    will get a little further.  Now we can rerun our functional tests and see if they pass, or get a little\n    further. That may prompt us to write some new unit tests, and some new code,\n    and so on.   Let\u2019s create a unit test for the todo app using flask\u2019s test client[^3] which\ndoes the same thing as the  test_can_check_homepage()  inside functional_test.py :  # tests/unit_test.py\n\nimport pytest\nfrom todoapp import app\n\n@pytest.fixture(scope='session')\ndef client():\n    app.config['TESTING'] = True\n    return app.test_client()\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    assert '<title>To-Do</title>' in rsp.get_data(as_text=True)  and run it  $ py.test tests/unit_test.py\n========================================== ERRORS ==========================================\n___________________________ ERROR collecting tests/unit_test.py ____________________________\ntests/unit_test.py:2: in <module>\n    import todoapp\nE   ImportError: No module named 'todoapp'  The app\u2019s module is not in the Python\u2019s path, so  pytest  can\u2019t import it. The\nsimplest way to fix this is to set the  PYTHONPATH  shell variable to the\ncurrent dir:  $ export PYTHONPATH='.'\n\n$ py.test -v tests/unit_test.py\n=================================== test session starts ====================================\n\ntests/unit_test.py::test_home_page_returns_correct_html PASSED\n\n======================= 1 passed, 1 pytest-warnings in 0.02 seconds  0.02 seconds is much better compared to 2.5 seconds needed to start a browser.  Since we know that the  home  view should return  home.html  template,\nwe can check the returned html as follows:  def test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    tpl = app.jinja_env.get_template('home.html')\n    assert tpl.render() == rsp.get_data(as_text=True)  At this point your project dir should look like (excluding  *.pyc  and __pycache__  dir):  \u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 functional_test.py\n\u2502 \u00a0 \u2514\u2500\u2500 unit_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 templates\n\u2502    \u00a0\u00a0 \u2514\u2500\u2500 home.html\n\u2514\u2500\u2500 venv\n  \u00a0 \u2514\u2500\u2500 bin\n...  Unittest  is the standard Python module for creating and running tests. Pytest  is an alternative testing framework. It requires less boilerplate code\nand is somewhat easier to use. We can adapt  functional_test.py  to test the\n\u201ccheck homepage\u201d feature as follows:  # tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef url(route):\n    return '{}/{}'.format(BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(url('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...  Note how the  browser  instance has been converted into a function decorated\nwith  yield_fixture 1 . It does the job of both  setUp()  and  tearDown() \nmethods of a  unittest.TestCase . It is possible to organize tests into classes,\nbut it is not required.  Before running  pytest , create a  setup.cfg  file to exclude  venv  (and other\ndirs if needed) from being in the tests auto-discovery path.  [pytest]\nnorecursedirs = .git venv  Now run the test (note that  pytest \u2018s runner is  py.test ):  $ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================  Use  py.test -ra  if you want to see what is causing  pytest-warnings .  Back to the app. \u201chello world\u201d is nice, but it has little to do with a todo app.\nThe test should look more like:  # Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title  $ py.test\n<... skipped lines ...>\n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser = <splinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8>\n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(url('/'))\n        # She notices the page title and header mention to-do lists\n>       assert 'To-Do' in browser.title\nE       assert 'To-Do' in ''\n<... skipped lines ...>  Note the last line. It shows the actual value of  browser.title  during the\ntest run. Time to update the app:  $ mkdir todoapp/templates\n$ touch todoapp/templates/home.html  <!-- todoapp/templates/home.html -->\n<html>\n<head>\n  <title>To-Do</title>\n</head>\n\n<body>\n  <h1>My todos list</h1>\n</body>\n\n</html>  # todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \"__main__\":\n    app.run(debug=True)  py.test  should now pass.   If you want a more explicit error message, change the assertion line like this:  \n    assert any(row.text == '1: Buy peacock feathers' for row in rows), \\\n           'New to-do item did not appear in the table'      Pytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.\u00a0 \u21a9",
            "title": "Testing user interactions"
        },
        {
            "location": "/tdd-advanced/",
            "text": "Testing with pytest-bdd\n\u00b6\n\n\nBeyond unit testing\n\u00b6",
            "title": "TDD Advanced"
        },
        {
            "location": "/tdd-advanced/#testing-with-pytest-bdd",
            "text": "",
            "title": "Testing with pytest-bdd"
        },
        {
            "location": "/tdd-advanced/#beyond-unit-testing",
            "text": "",
            "title": "Beyond unit testing"
        }
    ]
}