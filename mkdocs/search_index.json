{
    "docs": [
        {
            "location": "/",
            "text": "Test driven development with pytest\n\n\nTest Driven Development with Python\n book by  Harry Percival is\na nice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple \nDjango\n based web app\nusing \nunittest\n and \nSelenium\n for testing. Very\ncommon setup.  Here we will develop the same app using \nFlask\n and\ntest it with \npytest\n + \npytest-splinter\n and\n\npytest-bdd\n extensions.\n\n\nThis guide is aimed at developers with some experience in Python and web\nprogramming. This means some familiarity with things like \nurl routing\n, \nhttp\nrequests\n, \nhtml templating\n and the general MVC pattern. Basic knowledge about\nhow to use the command line interface (we\nll use \nbash\n) is also assumed.\n\n\nThis is a very basic how-to-get-started-with-testing guide. Hopefully enough to\novercome the initial learning barrier. I\nm not a \ntesting expert\n, and I don\nt\nwant to get into why anybody should be doing TDD or get into the depths of\nwhat\ns a \nunit\n, \nfunctional\n, \nacceptance\n or \nintegration\n test. You can read\nmore about testing in Harry\ns book, \nwikipedia\n and other\nauthoritative sources like \nthis one\n or \nthat one\n.\n\nhttp://gojko.net/\n is another useful resource.\n\n\nBoth this guide and the source of the app are on \nGitHub\n.\n\n\nConventions\n\n\nThere are two types of code blocks:\n\n\ncommand line \n what you need to type in a terminal (\n$\n indicates standard\n\nbash\n shell prompt),\n\n\n$ whoami\nivan\n$ python -V\nPython 3.5.0\n\n\n\n\nand Python code \n what you need to type inside a text editor (the first line\nstarting with \n#\n indicates the path to file relative to project\ns root\ndirectory.\n\n\n# path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "About"
        },
        {
            "location": "/#test-driven-development-with-pytest",
            "text": "Test Driven Development with Python  book by  Harry Percival is\na nice practical introduction to TDD with Python in the web development context.\nIt starts with the development of a simple  Django  based web app\nusing  unittest  and  Selenium  for testing. Very\ncommon setup.  Here we will develop the same app using  Flask  and\ntest it with  pytest  +  pytest-splinter  and pytest-bdd  extensions.  This guide is aimed at developers with some experience in Python and web\nprogramming. This means some familiarity with things like  url routing ,  http\nrequests ,  html templating  and the general MVC pattern. Basic knowledge about\nhow to use the command line interface (we ll use  bash ) is also assumed.  This is a very basic how-to-get-started-with-testing guide. Hopefully enough to\novercome the initial learning barrier. I m not a  testing expert , and I don t\nwant to get into why anybody should be doing TDD or get into the depths of\nwhat s a  unit ,  functional ,  acceptance  or  integration  test. You can read\nmore about testing in Harry s book,  wikipedia  and other\nauthoritative sources like  this one  or  that one . http://gojko.net/  is another useful resource.  Both this guide and the source of the app are on  GitHub .",
            "title": "Test driven development with pytest"
        },
        {
            "location": "/#conventions",
            "text": "There are two types of code blocks:  command line   what you need to type in a terminal ( $  indicates standard bash  shell prompt),  $ whoami\nivan\n$ python -V\nPython 3.5.0  and Python code   what you need to type inside a text editor (the first line\nstarting with  #  indicates the path to file relative to project s root\ndirectory.  # path/to/tests/test_file.py\nimport pytest\n\ndef test_sanity():\n    assert 2 + 2 == 4",
            "title": "Conventions"
        },
        {
            "location": "/tdd-basics/",
            "text": "TDD Basics\n\n\nHere we will build a simple todo app following roughly the same steps as in the\nPart I of \nTDD with Python\n book.\n\n\nProject setup\n\n\nFist of all we need to create the project\ns directory structure and install\nminimal requirements into a \nvirtualenv\n. Then we write the first test which\nshould obviously \nfail\n since there is no actual application code written at\nthis point. And then we write a minimal Flask app, just to get the test to pass.\n\n\n$ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.\n\n$ pip install Flask\n$ pip install pytest pytest-splinter\n\n\n\n\nCreate the \napp\n and \ntests\n dirs:\n\n\n$ mkdir todoapp tests\n\n\n\n\nEdit \ntests/functional_tests.py\n:\n\n\n# tests/functional_tests.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n\n\nRun the test:\n\n\n$ python tests/functional_test.py\nTraceback (most recent call last):\n  File \ntests/functional_test.py\n, line 8, in \nmodule\n\n      assert browser.is_text_present('hello world')\n      AssertionError\n\n\n\n\nAssertionError\n indicates test failure. Note that we haven\nt actually used\n\npytest\n yet. The file containing our first test is just a regular python\nscript\n1\n.\n\n\nNow, create a basic flask app:\n\n\n# todoapp/__init__.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ == \n__main__\n:\n    app.run()\n\n\n\n\nOpen another terminal, activate \nvenv\n, and run the app:\n\n\n$ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n\n\n\nRerun the test and see it pass.\nAt this point you should have the following files in your project directory:\n\n\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...\n\n\n\n\nStarting the actual app\n\n\nWe can use \nfunctional_test.py\n to guide the development of the todo app.  This\ncan be as simple as using comments to write a walk-through the app\ns features by\nan imaginary user. This is a variation on the\n\nReadme driven development\n theme.\n\n\n# tests/functional_test.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\n\n# She notices the page title and header mention to-do lists\n\n# She is invited to enter a to-do item straight away\n\n# She types \nBuy peacock feathers\n into a text box (Edith's hobby\n# is tying fly-fishing lures)\n\n# When she hits enter, the page updates, and now the page lists\n# \n1: Buy peacock feathers\n as an item in a to-do list\n\n# There is still a text box inviting her to add another item. She\n# enters \nUse peacock feathers to make a fly\n (Edith is very methodical)\n\n# The page updates again, and now shows both items on her list\n\n# Edith wonders whether the site will remember her list. Then she sees\n# that the site has generated a unique URL for her -- there is some\n# explanatory text to that effect.\n\n# She visits that URL - her to-do list is still there.\n\n# Satisfied, she goes back to sleep\n\n\n\n\nUnittest\n is the standard Python module for creating and running tests.\n\nPytest\n is an alternative testing framework. It requires less boilerplate code\nand is somewhat easier to use. We can adapt \nfunctional_test.py\n to test the\n\ncheck homepage\n feature as follows:\n\n\n# tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef url(route):\n    return '{}/{}'.format(BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(url('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...\n\n\n\n\nNote how the \nbrowser\n instance has been converted into a function decorated\nwith \nyield_fixture\n2\n. It does the job of both \nsetUp()\n and \ntearDown()\n\nmethods of a \nunittest.TestCase\n. It is possible to organize tests into classes,\nbut it is not required.\n\n\nBefore running \npytest\n, create a \nsetup.cfg\n file to exclude \nvenv\n (and other\ndirs if needed) from being in the tests auto-discovery path.\n\n\n[pytest]\nnorecursedirs = .git venv\n\n\n\n\nNow run the test (note that \npytest\ns runner is \npy.test\n):\n\n\n$ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================\n\n\n\n\nUse \npy.test -ra\n if you want to see what is causing \npytest-warnings\n.\n\n\nBack to the app. \nhello world\n is nice, but it has little to do with a todo app.\nThe test should look more like:\n\n\n# Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n\n\n\n\n$ py.test\n\n... skipped lines ...\n\n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser = \nsplinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8\n\n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(url('/'))\n        # She notices the page title and header mention to-do lists\n\n       assert 'To-Do' in browser.title\nE       assert 'To-Do' in ''\n\n... skipped lines ...\n\n\n\n\n\nNote the last line. It shows the actual value of \nbrowser.title\n during the\ntest run. Time to update the app:\n\n\n$ mkdir todoapp/templates\n$ touch todoapp/templates/home.html\n\n\n\n\n!-- todoapp/templates/home.html --\n\n\nhtml\n\n\nhead\n\n  \ntitle\nTo-Do\n/title\n\n\n/head\n\n\n\nbody\n\n  \nh1\nMy todos list\n/h1\n\n\n/body\n\n\n\n/html\n\n\n\n\n\n# todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ == \n__main__\n:\n    app.run(debug=True)\n\n\n\n\npy.test\n should now pass.\n\n\nUnit tests vs functional tests\n\n\nThe tests so far are called \nfunctional\n because they test an application from\nthe perspective of a user; open a browser, visit a url, etc. These tests work\nwithout any knowledge about the app\ns implementation details. Almost any kind of\nweb application, written in Python or another language, can be tested with\n\npytest\n and \nsplinter\n. On the other hand, unit tests (the concept and not the\n\nunittest\n module) are supposed to test an application from the developer\ns\npoint of view. Unit tests should cover very specific and usually very small\nparts of code. Therefore, there should be many more unit tests than functional\ntests.  Because of that unit tests must be fast. Opening and closing browsers is\nnot very useful in this context. As described in the TDDPy book, the development\nprocess goes as follows:\n\n\n\n\nStart by writing a functional test, describing the new functionality from\n    the user\ns point of view.\n\n\nOnce we have a functional test that fails, we start to think about how to\n    write code that can get it to pass (or at least to get past its current\n    failure). We now use one or more unit tests to define how we want our code to\n    behave \n the idea is that each line of production code we write should be\n    tested by (at least) one of our unit tests.\n\n\nOnce we have a failing unit test, we write the smallest amount of\n    application code we can, just enough to get the unit test to pass. We may\n    iterate between steps 2 and 3 a few times, until we think the functional test\n    will get a little further.\n\n\nNow we can rerun our functional tests and see if they pass, or get a little\n    further. That may prompt us to write some new unit tests, and some new code,\n    and so on.\n\n\n\n\nLet\ns create a unit test for the todo app using flask\ns test client\n3\n which\ndoes the same thing as the \ntest_can_check_homepage()\n inside\n\nfunctional_test.py\n:\n\n\n# tests/unit_test.py\n\nimport pytest\nfrom todoapp import app\n\n@pytest.fixture(scope='session')\ndef client():\n    app.config['TESTING'] = True\n    return app.test_client()\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    assert '\ntitle\nTo-Do\n/title\n' in rsp.get_data(as_text=True)\n\n\n\n\nand run it\n\n\n$ py.test tests/unit_test.py\n========================================== ERRORS ==========================================\n___________________________ ERROR collecting tests/unit_test.py ____________________________\ntests/unit_test.py:2: in \nmodule\n\n    import todoapp\nE   ImportError: No module named 'todoapp'\n\n\n\n\nThe app\ns module is not in the Python\ns path, so \npytest\n can\nt import it. The\nsimplest way to fix this is to set the \nPYTHONPATH\n shell variable to the\ncurrent dir:\n\n\n$ export PYTHONPATH='.'\n\n$ py.test -v tests/unit_test.py\n=================================== test session starts ====================================\n\ntests/unit_test.py::test_home_page_returns_correct_html PASSED\n\n======================= 1 passed, 1 pytest-warnings in 0.02 seconds\n\n\n\n\n0.02 seconds is much better compared to 2.5 seconds needed to start a browser.\n\n\nSince we know that the \nhome\n view should return \nhome.html\n template,\nwe can check the returned html as follows:\n\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    tpl = app.jinja_env.get_template('home.html')\n    assert tpl.render() == rsp.get_data(as_text=True)\n\n\n\n\nAt this point your project dir should look like (excluding \n*.pyc\n and\n\n__pycache__\n dir):\n\n\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 functional_test.py\n\u2502 \u00a0 \u2514\u2500\u2500 unit_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 templates\n\u2502    \u00a0\u00a0 \u2514\u2500\u2500 home.html\n\u2514\u2500\u2500 venv\n  \u00a0 \u2514\u2500\u2500 bin\n...\n\n\n\n\nTesting user interactions\n\n\nTime to get back to functional tests. The next step is to add user input\nfunctionality. This means adding \nform\n and \ninput\n elements in the app\ns\nhtml template. Let\ns do an explicit test for this inside \ntests/unit_test.py\n\ninstead of testing full template:\n\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '\nform' in html\n    assert '\ninput' in html\n\n\n\n\nThink about why we didn\nt \nclose\n the elements.\n\n\nUpdate the html template to make the test pass.\n\n\n!-- todoapp/templates/home.html --\n\n\n\nbody\n\n  \nh1\nMy todos list\n/h1\n\n  \nform\n\n    \ninput id=\nnew_todo_item\n name=\ntodo_text\n/\n\n  \n/form\n\n  \n/table\n\n\n/body\n\n\n\n\n\nWe can now update our functional test:\n\n\n# tests/function_test.html\n\n# ...\n\n# Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n    header = browser.find_by_tag('h1').first\n    assert 'todos' in header.text\n\n    # She is invited to enter a to-do item straight away\n    inputbox = browser.find_by_id('new_todo_item').first\n    assert inputbox['placeholder'] == 'Enter a to-do item'\n\n    # She types \nBuy peacock feathers\n into a text box\n    inputbox.type('Buy peacock feathers')\n\n    # When she hits enter...\n    inputbox.type('\\n')\n\n    # ...the page updates, and now the page lists\n    # \n1: Buy peacock feathers\n as an item in a to-do list\n\n\n\n\nWhat-you-type-is-what-you-get\n\n\nAt this point we need to decide what to do when the user hits \nEnter\n preferably\nwithout resorting to \ncss tricks\n and javascript. Turns out\nthat an html form containing a single \ninput\n is implicitly submitted on\n\nEnter\n4\n. All we need to do is to specify that submit method is \nPOST\n and to\nadd a list or table to the template which will display submitted todo items. But\nwrite the tests first!\n\n\n# tests/unit_test.py\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert '\nform' in html\n    assert '\ninput' in html\n    assert '\ntable' in html\n\ndef test_home_page_accepts_post_request(client):\n    rsp = client.post('/', data={\ntodo_text\n: \ndo something useful\n})\n    assert rsp.status == '200 OK'\n    assert 'do something useful' in rsp.get_data(as_text=True)\n\n\n\n\nNow update the template.\n\n\n!-- todoapp/templates/home.html --\n\n\nbody\n\n  \nh1\nMy todos list\n/h1\n\n  \nform method=\nPOST\n\n    \ninput id=\nnew_todo_item\n name=\ntodo_text\n/\n\n  \n/form\n\n\n  \ntable id=\ntodo_list_table\n/table\n\n\n/body\n\n\n\n\n\nRun unit tests.\n\n\n$ py.test tests/unit_test.py\n================================ test session starts =================================\n\n    def test_home_page_accepts_post_request(client):\n        rsp = client.post('/')\n\n       assert rsp.status == '200 OK'\nE       assert '405 METHOD NOT ALLOWED' == '200 OK'\nE         - 405 METHOD NOT ALLOWED\nE         + 200 OK\n\ntests/unit_test.py:21: AssertionError\n=============== 1 failed, 1 passed, 1 pytest-warnings in 0.03 seconds ================\n\n\n\n\n\nFlask routes accept only \nGET\n requests by default, but this is easily changed\nusing \nmethods\n keyword. We will also need to import flask\ns \nrequest\n object.\n\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'POST':\n        new_item = request.form.get('todo_text')\n        return 'got new item: %s' % new_item\n    return render_template('home.html')\n\n\n\n\nIf you want a more explicit error message, change the assertion line like this:\n\n\n\n    assert any(row.text == '1: Buy peacock feathers' for row in rows), \\\n           'New to-do item did not appear in the table'\n\n\n\n\n\n\n\n\n\n\n\n\n\nNon-trivial apps will have many tests organized in multiple functions or\nclasses. That\ns when we need to use a \ntest runner\n \n a command that discovers\nand runs all the tests, and then reports which ones have passed or failed.\n\n\n\n\n\n\nPytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.\n\n\n\n\n\n\nclient\n is a generic way to refer to code or application running on the\nuser\ns side (like web browsers) in the client-server software design model.\n\n\n\n\n\n\nIntroduced in HTML 2.0, and currently described under\n  \nimplicit submission\n\n  section of HTML 5 specification.",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#tdd-basics",
            "text": "Here we will build a simple todo app following roughly the same steps as in the\nPart I of  TDD with Python  book.",
            "title": "TDD Basics"
        },
        {
            "location": "/tdd-basics/#project-setup",
            "text": "Fist of all we need to create the project s directory structure and install\nminimal requirements into a  virtualenv . Then we write the first test which\nshould obviously  fail  since there is no actual application code written at\nthis point. And then we write a minimal Flask app, just to get the test to pass.  $ cd ~/Projects\n$ mkdir tdd-todoapp\n$ cd tdd-todoapp\n$ pyvenv venv\n$ . venv/bin/activate\n$ python -V\nPython 3.5.\n\n$ pip install Flask\n$ pip install pytest pytest-splinter  Create the  app  and  tests  dirs:  $ mkdir todoapp tests  Edit  tests/functional_tests.py :  # tests/functional_tests.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')  Run the test:  $ python tests/functional_test.py\nTraceback (most recent call last):\n  File  tests/functional_test.py , line 8, in  module \n      assert browser.is_text_present('hello world')\n      AssertionError  AssertionError  indicates test failure. Note that we haven t actually used pytest  yet. The file containing our first test is just a regular python\nscript 1 .  Now, create a basic flask app:  # todoapp/__init__.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'hello world'\n\nif __name__ ==  __main__ :\n    app.run()  Open another terminal, activate  venv , and run the app:  $ python todoapp/__init__.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)  Rerun the test and see it pass.\nAt this point you should have the following files in your project directory:  \u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 functional_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 venv\n    \u251c\u2500\u2500 bin\n    \u251c\u2500\u2500 include\n    ...",
            "title": "Project setup"
        },
        {
            "location": "/tdd-basics/#starting-the-actual-app",
            "text": "We can use  functional_test.py  to guide the development of the todo app.  This\ncan be as simple as using comments to write a walk-through the app s features by\nan imaginary user. This is a variation on the Readme driven development  theme.  # tests/functional_test.py\nfrom splinter import Browser\n\nBASE_URL = 'http://localhost:5000'\n\nwith Browser() as browser:\n    browser.visit(BASE_URL)\n    assert browser.is_text_present('hello world')\n\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\n\n# She notices the page title and header mention to-do lists\n\n# She is invited to enter a to-do item straight away\n\n# She types  Buy peacock feathers  into a text box (Edith's hobby\n# is tying fly-fishing lures)\n\n# When she hits enter, the page updates, and now the page lists\n#  1: Buy peacock feathers  as an item in a to-do list\n\n# There is still a text box inviting her to add another item. She\n# enters  Use peacock feathers to make a fly  (Edith is very methodical)\n\n# The page updates again, and now shows both items on her list\n\n# Edith wonders whether the site will remember her list. Then she sees\n# that the site has generated a unique URL for her -- there is some\n# explanatory text to that effect.\n\n# She visits that URL - her to-do list is still there.\n\n# Satisfied, she goes back to sleep  Unittest  is the standard Python module for creating and running tests. Pytest  is an alternative testing framework. It requires less boilerplate code\nand is somewhat easier to use. We can adapt  functional_test.py  to test the check homepage  feature as follows:  # tests/functional_test.py\nimport pytest\nfrom splinter import Browser\n\n@pytest.yield_fixture(scope='session')\ndef browser():\n    b = Browser()\n    yield b\n    b.quit()\n\nBASE_URL = 'http://localhost:5000'\n\ndef url(route):\n    return '{}/{}'.format(BASE_URL, route)\n\n# Edith has heard about a cool new online to-do app.\n# She goes to check out its homepage\ndef test_can_check_homepage(browser):\n    browser.visit(url('/'))\n    assert browser.is_text_present('hello world')\n\n# She notices the page title and header mention to-do lists\n# ...  Note how the  browser  instance has been converted into a function decorated\nwith  yield_fixture 2 . It does the job of both  setUp()  and  tearDown() \nmethods of a  unittest.TestCase . It is possible to organize tests into classes,\nbut it is not required.  Before running  pytest , create a  setup.cfg  file to exclude  venv  (and other\ndirs if needed) from being in the tests auto-discovery path.  [pytest]\nnorecursedirs = .git venv  Now run the test (note that  pytest s runner is  py.test ):  $ py.test -v\n=================================== test session starts ====================================\nplatform darwin -- Python 3.5.0, pytest-2.8.3, py-1.4.31, pluggy-0.3.1 -- /Users/ivan/Projects/tdd-todoapp/venv/bin/python3.5\ncachedir: .cache\nrootdir: /Users/ivan/Projects/tdd-todoapp, inifile: setup.cfg\nplugins: splinter-1.7.0, xdist-1.13.1\ncollected 1 items\n\ntests/functional_test.py::test_can_check_homepage PASSED\n\n======================= 1 passed, 1 pytest-warnings in 2.34 seconds ========================  Use  py.test -ra  if you want to see what is causing  pytest-warnings .  Back to the app.  hello world  is nice, but it has little to do with a todo app.\nThe test should look more like:  # Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title  $ py.test ... skipped lines ... \n========================================= FAILURES =========================================\n_________________________________ test_can_check_homepage __________________________________\n\nbrowser =  splinter.driver.webdriver.firefox.WebDriver object at 0x106a3d7b8 \n\n    def test_can_check_homepage(browser):\n        # She goes to check out its homepage\n        browser.visit(url('/'))\n        # She notices the page title and header mention to-do lists        assert 'To-Do' in browser.title\nE       assert 'To-Do' in '' ... skipped lines ...   Note the last line. It shows the actual value of  browser.title  during the\ntest run. Time to update the app:  $ mkdir todoapp/templates\n$ touch todoapp/templates/home.html  !-- todoapp/templates/home.html --  html  head \n   title To-Do /title  /head  body \n   h1 My todos list /h1  /body  /html   # todoapp/__init__.py\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\nif __name__ ==  __main__ :\n    app.run(debug=True)  py.test  should now pass.",
            "title": "Starting the actual app"
        },
        {
            "location": "/tdd-basics/#unit-tests-vs-functional-tests",
            "text": "The tests so far are called  functional  because they test an application from\nthe perspective of a user; open a browser, visit a url, etc. These tests work\nwithout any knowledge about the app s implementation details. Almost any kind of\nweb application, written in Python or another language, can be tested with pytest  and  splinter . On the other hand, unit tests (the concept and not the unittest  module) are supposed to test an application from the developer s\npoint of view. Unit tests should cover very specific and usually very small\nparts of code. Therefore, there should be many more unit tests than functional\ntests.  Because of that unit tests must be fast. Opening and closing browsers is\nnot very useful in this context. As described in the TDDPy book, the development\nprocess goes as follows:   Start by writing a functional test, describing the new functionality from\n    the user s point of view.  Once we have a functional test that fails, we start to think about how to\n    write code that can get it to pass (or at least to get past its current\n    failure). We now use one or more unit tests to define how we want our code to\n    behave   the idea is that each line of production code we write should be\n    tested by (at least) one of our unit tests.  Once we have a failing unit test, we write the smallest amount of\n    application code we can, just enough to get the unit test to pass. We may\n    iterate between steps 2 and 3 a few times, until we think the functional test\n    will get a little further.  Now we can rerun our functional tests and see if they pass, or get a little\n    further. That may prompt us to write some new unit tests, and some new code,\n    and so on.   Let s create a unit test for the todo app using flask s test client 3  which\ndoes the same thing as the  test_can_check_homepage()  inside functional_test.py :  # tests/unit_test.py\n\nimport pytest\nfrom todoapp import app\n\n@pytest.fixture(scope='session')\ndef client():\n    app.config['TESTING'] = True\n    return app.test_client()\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    assert ' title To-Do /title ' in rsp.get_data(as_text=True)  and run it  $ py.test tests/unit_test.py\n========================================== ERRORS ==========================================\n___________________________ ERROR collecting tests/unit_test.py ____________________________\ntests/unit_test.py:2: in  module \n    import todoapp\nE   ImportError: No module named 'todoapp'  The app s module is not in the Python s path, so  pytest  can t import it. The\nsimplest way to fix this is to set the  PYTHONPATH  shell variable to the\ncurrent dir:  $ export PYTHONPATH='.'\n\n$ py.test -v tests/unit_test.py\n=================================== test session starts ====================================\n\ntests/unit_test.py::test_home_page_returns_correct_html PASSED\n\n======================= 1 passed, 1 pytest-warnings in 0.02 seconds  0.02 seconds is much better compared to 2.5 seconds needed to start a browser.  Since we know that the  home  view should return  home.html  template,\nwe can check the returned html as follows:  def test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    tpl = app.jinja_env.get_template('home.html')\n    assert tpl.render() == rsp.get_data(as_text=True)  At this point your project dir should look like (excluding  *.pyc  and __pycache__  dir):  \u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 functional_test.py\n\u2502 \u00a0 \u2514\u2500\u2500 unit_test.py\n\u251c\u2500\u2500 todoapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 templates\n\u2502    \u00a0\u00a0 \u2514\u2500\u2500 home.html\n\u2514\u2500\u2500 venv\n  \u00a0 \u2514\u2500\u2500 bin\n...",
            "title": "Unit tests vs functional tests"
        },
        {
            "location": "/tdd-basics/#testing-user-interactions",
            "text": "Time to get back to functional tests. The next step is to add user input\nfunctionality. This means adding  form  and  input  elements in the app s\nhtml template. Let s do an explicit test for this inside  tests/unit_test.py \ninstead of testing full template:  def test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert ' form' in html\n    assert ' input' in html  Think about why we didn t  close  the elements.  Update the html template to make the test pass.  !-- todoapp/templates/home.html --  body \n   h1 My todos list /h1 \n   form \n     input id= new_todo_item  name= todo_text / \n   /form \n   /table  /body   We can now update our functional test:  # tests/function_test.html\n\n# ...\n\n# Edith has heard about a cool new online to-do app.\ndef test_can_check_homepage(browser):\n    # She goes to check out its homepage\n    browser.visit(url('/'))\n\n    # She notices the page title and header mention to-do lists\n    assert 'To-Do' in browser.title\n    header = browser.find_by_tag('h1').first\n    assert 'todos' in header.text\n\n    # She is invited to enter a to-do item straight away\n    inputbox = browser.find_by_id('new_todo_item').first\n    assert inputbox['placeholder'] == 'Enter a to-do item'\n\n    # She types  Buy peacock feathers  into a text box\n    inputbox.type('Buy peacock feathers')\n\n    # When she hits enter...\n    inputbox.type('\\n')\n\n    # ...the page updates, and now the page lists\n    #  1: Buy peacock feathers  as an item in a to-do list  What-you-type-is-what-you-get  At this point we need to decide what to do when the user hits  Enter  preferably\nwithout resorting to  css tricks  and javascript. Turns out\nthat an html form containing a single  input  is implicitly submitted on Enter 4 . All we need to do is to specify that submit method is  POST  and to\nadd a list or table to the template which will display submitted todo items. But\nwrite the tests first!  # tests/unit_test.py\n\ndef test_home_page_returns_correct_html(client):\n    rsp = client.get('/')\n    assert rsp.status == '200 OK'\n    html = rsp.get_data(as_text=True)\n    assert ' form' in html\n    assert ' input' in html\n    assert ' table' in html\n\ndef test_home_page_accepts_post_request(client):\n    rsp = client.post('/', data={ todo_text :  do something useful })\n    assert rsp.status == '200 OK'\n    assert 'do something useful' in rsp.get_data(as_text=True)  Now update the template.  !-- todoapp/templates/home.html --  body \n   h1 My todos list /h1 \n   form method= POST \n     input id= new_todo_item  name= todo_text / \n   /form \n\n   table id= todo_list_table /table  /body   Run unit tests.  $ py.test tests/unit_test.py\n================================ test session starts =================================\n\n    def test_home_page_accepts_post_request(client):\n        rsp = client.post('/')        assert rsp.status == '200 OK'\nE       assert '405 METHOD NOT ALLOWED' == '200 OK'\nE         - 405 METHOD NOT ALLOWED\nE         + 200 OK\n\ntests/unit_test.py:21: AssertionError\n=============== 1 failed, 1 passed, 1 pytest-warnings in 0.03 seconds ================  Flask routes accept only  GET  requests by default, but this is easily changed\nusing  methods  keyword. We will also need to import flask s  request  object.  from flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'POST':\n        new_item = request.form.get('todo_text')\n        return 'got new item: %s' % new_item\n    return render_template('home.html')  If you want a more explicit error message, change the assertion line like this:  \n    assert any(row.text == '1: Buy peacock feathers' for row in rows), \\\n           'New to-do item did not appear in the table'      Non-trivial apps will have many tests organized in multiple functions or\nclasses. That s when we need to use a  test runner    a command that discovers\nand runs all the tests, and then reports which ones have passed or failed.    Pytest fixtures must be callable objects passed to test functions as\narguments. Inside a test function we get an instance of the return or yield\nobject.    client  is a generic way to refer to code or application running on the\nuser s side (like web browsers) in the client-server software design model.    Introduced in HTML 2.0, and currently described under\n   implicit submission \n  section of HTML 5 specification.",
            "title": "Testing user interactions"
        },
        {
            "location": "/tdd-advanced/",
            "text": "Testing with pytest-bdd\n\n\nBeyond unit testing",
            "title": "TDD Advanced"
        },
        {
            "location": "/tdd-advanced/#testing-with-pytest-bdd",
            "text": "",
            "title": "Testing with pytest-bdd"
        },
        {
            "location": "/tdd-advanced/#beyond-unit-testing",
            "text": "",
            "title": "Beyond unit testing"
        }
    ]
}